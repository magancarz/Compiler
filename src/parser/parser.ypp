%{
    #include <stdio.h>
    #include <iostream>
    #include <fstream>
    #include <string>

    #include "../CodeGenerator.h"
    #include "../Memory.h"
    #include "../Variable.h"

    extern FILE* yyin;

    CodeGenerator* codeGenerator;
    Memory* memory;

    int yylex(void);
    void yyerror(std::string error);
    %}

    %code requires {
    #include "../CodeGenerator.h"
    #include "../Variable.h"
}

%union {
    unsigned int num;
    std::string* str;
    Variable* var;
    Condition* condit;
}

%token PROCEDURE PROGRAM IS VAR _BEGIN END
%token IF THEN ELSE ENDIF
%token WHILE DO ENDWHILE
%token REPEAT UNTIL
%token READ WRITE
%token NUM IDENTIFIER
%token COMMA SEMICOLON LB RB
%token ASSIGN
%left PLUS MINUS MUL DIV MOD 
%token EQ NEQ GREATER LESS GREQ LEQ
%token TEST

%type <var> value
%type <num> NUM expression commands command
%type <condit> condition
%type <str> IDENTIFIER execute_proc_head

%%

program_all: 
    procedures main

procedures:
    %empty
    | procedures procedure                                                  
    | procedure                                                             

procedure:
    PROCEDURE proc_head IS VAR proc_head_declarations _BEGIN commands END   { codeGenerator->generateProcedureEndCode(memory, memory->finishProcedure($7));
                                                                              memory->clearCurrentProcedure(); }
    | PROCEDURE proc_head IS _BEGIN commands END                            { codeGenerator->generateProcedureEndCode(memory, memory->finishProcedure($5));
                                                                              memory->clearCurrentProcedure(); }

main:
    PROGRAM IS VAR declarations _BEGIN commands END                         { codeGenerator->writeCode("HALT"); }
    | PROGRAM IS _BEGIN commands END                                        { codeGenerator->writeCode("HALT"); }

commands:
    commands command                                                        { $$ = $1 + $2; }
    | command                                                               

command:
    %empty                                                                  
    | IDENTIFIER ASSIGN expression SEMICOLON                                { $$ = codeGenerator->assignValueToVariable(memory, *$1, $3) + $3; }
    | IF condition THEN commands ELSE commands ENDIF                        { $$ = codeGenerator->ifElseCondition(memory, $2, $4, $6) + $4 + $6; }
    | IF condition THEN commands ENDIF                                      { $$ = codeGenerator->ifCondition(memory, $2, $4) + $4; }
    | WHILE condition DO commands ENDWHILE                                  { $$ = codeGenerator->whileLoop(memory, $2, $4) + $4; }
    | REPEAT commands UNTIL condition SEMICOLON                             { $$ = codeGenerator->repeatUntilLoop(memory, $4, $2) + $2; }
    | execute_proc_head                                                     { $$ = codeGenerator->executeProcedure(memory, *$1, memory->getProcedureExecutionVariables()); }
    | READ IDENTIFIER SEMICOLON                                             { $$ = codeGenerator->readValue(memory, *$2); }
    | WRITE value SEMICOLON                                                 { $$ = codeGenerator->printOutValue(memory, $2); }

execute_proc_head:
    IDENTIFIER LB execute_proc_head_declarations RB                         

execute_proc_head_declarations:
    execute_proc_head_declarations COMMA execute_proc_head_declaration      
    | execute_proc_head_declaration                                                 
    
execute_proc_head_declaration:
    IDENTIFIER                                                              { memory->prepareProcedureExecutionVariable(memory, *$1); }

proc_head:
    IDENTIFIER LB proc_head_declarations RB                                 { memory->setIdentifierToCurrentProcedure(*$1); }

proc_head_declarations:
    | proc_head_declarations COMMA proc_head_declaration                      
    | proc_head_declaration                                                 
    
proc_head_declaration:
    IDENTIFIER                                                              { memory->addVariableToProcedure(*$1); }

declarations:
    declarations COMMA declaration                                          
    | declaration                                                           

declaration:
    IDENTIFIER                                                              { memory->addVariableToMemory(*$1, 0); }

expression:
    value                                                                   { $$ = codeGenerator->setValueToAccumulator(memory, $1); }
    | value PLUS value                                                      { $$ = codeGenerator->add(memory, $1, $3); }
    | value MINUS value                                                     { $$ = codeGenerator->sub(memory, $1, $3); }
    | value MUL value                                                       { $$ = codeGenerator->mul(memory, $1, $3); }
    | value DIV value                                                       { $$ = codeGenerator->div(memory, $1, $3); }
    | value MOD value                                                       { $$ = codeGenerator->mod(memory, $1, $3); }

condition:
    value EQ value                                                          { $$ = codeGenerator->equal(memory, $1, $3); }
    | value NEQ value                                                       { $$ = codeGenerator->nequal(memory, $1, $3); }
    | value GREATER value                                                   { $$ = codeGenerator->greater(memory, $1, $3); }
    | value LESS value                                                      { $$ = codeGenerator->less(memory, $1, $3); }
    | value GREQ value                                                      { $$ = codeGenerator->greq(memory, $1, $3); }
    | value LEQ value                                                       { $$ = codeGenerator->leq(memory, $1, $3); }

value:
    NUM                                                                     { $$ = memory->getValueHolder($1); }
    | IDENTIFIER                                                            { $$ = memory->getVariableFromMemory(*$1); }

%%

void yyerror(std::string error) {
    std::cout << error << std::endl;
    exit(1);
}

int parser_main(int argc, char** argv) {
    codeGenerator = new CodeGenerator(argc, argv);
    memory = new Memory();

    yyin = codeGenerator->getInput();

    try {
        yyparse();
    } catch(std::string error) {
        yyerror(error);
    }
    
    std::cout << codeGenerator->getCode() << std::endl;

    delete memory;
    delete codeGenerator;

    return 0;
}